## GNL

### Get_Next_Line : 읽어온 파일의 한 줄을 반환하는 프로그램

### 맨처음 든 생각

**솔직히 맨처음에 문제를 읽어서 뭔소리인지 1도 몰랐다.  그래서 바로 테스터기에 있는 main함수를 보게 되었다. 그러고 난뒤에 어떤 로직으로 돌아가겠구나 라는 생각을 하게 되었고, 왜 static을 써서 해야하는지도 감이 오게됬다.  위에 서도 작성 했듯이 static 프로그램이 종료되지 않는 이상 메모리상에 계속 존재하기 때문에 전에 값들을 저장해놓을수 있다. 이를 볼수 있는 예시를 작성해보면**

```tex
abcd
1234W
```

**이러한 txt 값을 불러올때 BUFFER_SIZE를 6이라고 가정해보자.** 

**우리가 원하는 gnl 이 실행되면 첫 호출때 리턴값은 1 이고 line 에는 "abcd" 가 들어가 있다. 이후 두번째 호출때 리턴값은 0이(EOF이기 때문에)되고 line에는 "1234"가 들어가게 된다. **

**하지만 생각해보면 첫 호출때 1을 리턴을하고 "abcd\n1" 이 들어가게 되는데 이러면 다음 호출때 BUFFER_SIZE 만큼 읽게 된다면? "234" 가 될것이다. 어 근데 이러면 안될꺼 라는 생각이 들어버렸다.**

**그래서 전에 있는 값에서 뉴라인 이후에 있는 값을 저장때리고,  그값을 다시 호출했을때 값하고 1 + 234 이런식으로 진행하면 되지 않을까 라는 생각을 했다** 

### 서브젝트를 보고 알아야할 점

1. **EOF(End Of File)**

2. **파일 디스크럽터(fd)**

3. **read() 함수**

   ``ssize_t read(int fd, void *buf, size_t nbytes)``

   1. **fd** : 파일 디스크립터

   2. ***buf** : 파일을 읽어 들일 버퍼

   3. **nbytes** : 버퍼의 크기

   4. **return**

      1. **성공시 반환 값** : 읽은 바이트 수
      2. **파일 끝인 경우 반환 값** : 0
      3. **오류시 반환 값** : -1 

   5. **offest의 개념** ([출처 링크](https://code4human.tistory.com/130))

      이건 블로그를 통해서 알게 됬는데, `read`함수를 수행하면 데이터를 읽은 만큼 offset을 증가시킨다고 한다. 다시 파일을 읽으려하면 마지막 읽은 파일 위치부터 읽어드린다.

      여기에 대한 이유는 `read`함수는 **파일 디스크립터 테이블(FD Table)**에서 **읽은 위치(offset)를 저장**하기 때문이다.

4. **정적 변수**

   1. 초기화 하지 않으면 0으로 초기화됨

      ex)`static int num;`

      ```c
      static int a;
      
      int main(void)
      {
      	printf("%d", a);
      }
      //결과 : 0
      ```

   2. 함수가 끝나도 사라지지 않음.

      ```c
      static int a;
      
      void test(void)
      {
          a += 1;
          printf("%d", a);
      }
      
      int main(void)
      {
          test();
          test();
      }
      //결과 1 2
      ```

5. **컴파일 옵션 D**

6. **ssize_t**

   1. signed int ( 반환값으로 해당 IO 함수의 실패여부를 알려준다.)


7. **line이 이중 포인터 받는 이유**

    	line에 메모리 할당을 하면서 값이 바뀌는데, 이 바뀐 주소를 리턴하는 것이 아니므로 함수 바깥으로 전달되지 않음.
    

